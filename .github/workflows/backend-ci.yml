# .github/workflows/backend-ci.yml

name: CI for Backend Services and Update Manifest

on:
  push:
    branches:
      - dev
    paths:
      - 'backend/**'  # B.E 디렉토리 하위의 모든 변경에 대해 실행

jobs:
  # 변경된 서비스가 무엇인지 결정하는 작업
  determine-services:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.get-service-names.outputs.services }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 모든 히스토리 가져오기 (변경분 감지를 위해)

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44

      - name: Determine changed service names
        id: get-service-names
        run: |
          # 변경된 파일 목록에서 서비스 이름 추출 (예: B.E/user-service/...)
          SERVICES=()
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ "$file" == backend/* ]]; then
              SERVICE_NAME=$(echo "$file" | cut -d'/' -f2)
              # 중복 제거
              if [[ ! " ${SERVICES[@]} " =~ " ${SERVICE_NAME} " ]]; then
                SERVICES+=("$SERVICE_NAME")
              fi
            fi
          done
          
          if [ ${#SERVICES[@]} -eq 0 ]; then
            echo "No changes detected in any B.E service."
            echo "services=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # JSON 배열로 출력 (공백과 쉼표 문제 해결)
          SERVICES_JSON=$(printf '%s\n' "${SERVICES[@]}" | jq -R . | jq -s . | tr -d ' \n')
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Detected services: ${SERVICES[*]}"
          echo "Services JSON: $SERVICES_JSON"

  # 결정된 서비스들을 병렬로 빌드하고, 이미지를 푸시하고, 매니페스트를 업데이트하는 작업
  build-and-update:
    needs: determine-services # determine-services 작업이 성공해야 실행
    if: needs.determine-services.outputs.services != '[]' # 서비스 목록이 비어있지 않을 때만 실행
    strategy:
      matrix:
        service: ${{ fromJson(needs.determine-services.outputs.services) }}
    runs-on: ubuntu-latest
    
    env:
      AWS_REGION: ap-northeast-2
      SERVICE_NAME: ${{ matrix.service }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout source code
        uses: actions/checkout@v4

      # 2. AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.BE_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.BE_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 3. Amazon ECR 로그인
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4. Java(JDK) 및 Gradle 환경 설정 (Java 서비스인 경우)
      - name: Setup Java JDK
        if: contains(matrix.service, 'user-service') || contains(matrix.service, 'order-service') || contains(matrix.service, 'community-service') || contains(matrix.service, 'review-service')
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      # 5. Python 환경 설정 (Python 서비스인 경우)
      - name: Setup Python
        if: matrix.service == 'image-service'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # 6. Docker 이미지 빌드 및 ECR 푸시
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "Building ${{ env.SERVICE_NAME }} service..."
          # image-service는 루트 디렉토리를 컨텍스트로 사용 (scripts 접근을 위해)
          if [ "${{ env.SERVICE_NAME }}" = "image-service" ]; then
            docker build -t $ECR_REGISTRY/sang3jeom/${{ env.SERVICE_NAME }}:$IMAGE_TAG -f ./backend/${{ env.SERVICE_NAME }}/Dockerfile .
          else
            # 다른 서비스들은 서비스 디렉토리를 컨텍스트로 사용
            cd backend/${{ env.SERVICE_NAME }}
            docker build -t $ECR_REGISTRY/sang3jeom/${{ env.SERVICE_NAME }}:$IMAGE_TAG .
          fi
          echo "Pushing ${{ env.SERVICE_NAME }} service to ECR..."
          docker push $ECR_REGISTRY/sang3jeom/${{ env.SERVICE_NAME }}:$IMAGE_TAG
          echo "Successfully built and pushed ${{ env.SERVICE_NAME }} service"

      # 7. Manifest 레포지토리 체크아웃
      - name: Checkout Manifest Repository
        uses: actions/checkout@v4
        with:
          # HTTPS 주소로 변경. 예: your-org/k8s-manifest-repo
          repository: sang3jeom/k8s-manifest-repo
          # ssh-key 대신 token을 사용하고, 시크릿 이름도 변경
          token: ${{ secrets.MANIFEST_REPO_PAT }}
          path: k8s-manifest-repo

      # 8. 직접 매니페스트 파일의 이미지 태그 업데이트 (Helm 차트 대신)
      - name: Install yq and update image tag in manifest
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          # 동적으로 해당 서비스의 매니페스트 파일 경로를 지정하여 이미지 태그 업데이트
          echo "Updating image tag for ${{ env.SERVICE_NAME }} service..."
          yq e '(select(.kind == "Deployment") | .spec.template.spec.containers[0].image) = "${{ steps.login-ecr.outputs.registry }}/sang3jeom/${{ env.SERVICE_NAME }}:${{ env.IMAGE_TAG }}"' -i k8s-manifest-repo/charts/${{ env.SERVICE_NAME }}/service.yaml
      # 9. Manifest 레포지토리에 변경사항 커밋 및 푸시
      - name: Commit and push manifest changes
        run: |
          cd k8s-manifest-repo
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add .
          git commit -m "Update image to ${{ env.IMAGE_TAG }} for ${{ env.SERVICE_NAME }}"
          git push
          echo "Successfully updated manifest for ${{ env.SERVICE_NAME }} service"
          echo "ArgoCD will automatically detect the changes and sync the application"

      # ArgoCD는 GitOps 방식으로 작동하므로, 
      # 매니페스트 레포지토리의 변경사항을 자동으로 감지하여 동기화를 수행합니다.
      # 별도의 수동 동기화가 필요하지 않습니다.